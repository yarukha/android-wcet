\documentclass{beamer}
\usepackage{amsmath}
\usepackage{stmaryrd}
%Information to be included in the title page:
\title{Profiling energy consumption of Android applications}
\author{Paul Robert}
\date{2022}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Overview and goals}
\pause
\begin{itemize}
    \item Classify applications based on their "energy consumption"
    \pause
    \item Static analysis on packaged apps (APK)
    \pause
    \item Several approximations to identify
\end{itemize}


\end{frame}


\begin{frame}{Structure of the project}
\begin{itemize}
    \item 3 main parts can be identified
    \pause
    \item Analysis of the APK
    \pause 
    \item Definition of a power model
    \pause
    \item The "in between", analysis of the CFG
\end{itemize}

\end{frame}

\begin{frame}{Android programs structure}
\begin{itemize}
    \item modified java bytecode (.dex files) 
    \pause
    \item use features inherited from java and several improvements
    \pause
    \item We need to ignore several features (AOT compilation, reflection and others...)
    \pause
    \item Compilation chain: Development language $\rightarrow$ Java $\rightarrow$ Intermediate languages $\rightarrow$ Java bytecode $\rightarrow$ Dalvik/ART bytecode
    \pause
    \item Which level of code do we use to create a CFG? 
    \pause
    \item Short answer: Working at the lowest level allows to easily specify an energy model
\end{itemize}
    
\end{frame}

\begin{frame}{Power model}
\begin{itemize}
    \item Current idea: associate each bytecode instruction to a consumption value (time and/or energy)
    \pause  
    \item VERY simple model, ignore parameters of instruction, system and hardware calls
    \pause 
    \item Create several test programs, count the number of each bytecode instructions and mesure the total energy/time of each program
    \pause
    \item We get a system to solve: $I_{count} X = E_{total}$
    \pause
    \item We can do that for both time and energy consumption of each bytecode instruction
    \pause 
    \item Idea of consumption profiling: max energy consumed in a given time
\end{itemize}
    
\end{frame}

\begin{frame}{Implementing the profiling model}
\begin{itemize}
    \item A simple prototype can be created by ignoring conditional branching
    \pause
    \item Can start at any point of the CFG
    \pause 
    \item We can extend the profiling: (average of paths, worst case...)
    \pause 
    \item We still need to figure out which parts of the CFG are accessible
\end{itemize}
    
\end{frame}

\begin{frame}{Abstract interpretation}
\begin{itemize}
    
    \item Gives a framework to do static analysis on the CFG $E\subseteq V \times Op \times V$
    \pause 
    \item Given an abstraction function $\llbracket\rrbracket: Op \rightarrow (A\rightarrow A)$
    \pause 
    \item Fixpoint of the functionnal $F: (V\rightarrow A) \rightarrow (V\rightarrow A)$: \\
    \begin{equation}
        F(f)(v')= \begin{cases}
            l_0 & \text{if } v=v_0\\
            \bigsqcup\limits_{(v,op,v')\in E} \llbracket op \rrbracket (f(v)) & \text{otherwise}
        \end{cases}
    \end{equation}
    \pause 
    \item For $A= [1,maxint]$, $Op$ the bytecode instructions, $\llbracket \rrbracket$ the energy model and $\bigsqcup = max$, we obtain a function giving the total energy consumed for each program state 
\end{itemize}
    

\end{frame}

\begin{frame}{Abstract interpretation}
    
    \begin{itemize}
        \item We can work with several lattices at a time: $[0,max_{time}] \times [0,max_{energy}] $, remove cycles by taking all possible path: prototype is done
        \pause 
        \item Still need to recognize conditional branching to have correct results
        \pause 
        \item we can consider the current value (or an approximation) of each register to solve this problem
        \pause 
        \item Constant propagation, interval analysis, pipeline analysis ...
        \pause 
        \item We can also compute intervals of consumption for sections of code 
        \pause 
        \item It all comes down to defining a lattice and an abstraction function
    \end{itemize}
\end{frame}
\end{document}