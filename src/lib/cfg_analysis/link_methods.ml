open Scfg
open Instructions








let split_block l :block list= 
  List.fold_right (
    fun i b -> match b with 
    |[]->[[i]]
    |x::q->
      match i.op with 
      |Opn(Invoke(_),_)->[i]::b
      |_->match (List.hd x).op with 
        |Opn(Invoke(_),_)->[i]::b 
        |_->(i::x)::q
  ) l []

(*this function uses very sketchy techniques, each new node generated by a former node of id x
   will have id "x0i" where i is the ith splitted block*)
(*we also use List.tl to test if a block has size 1 and hence an invoke block*)
(**for now all the invokes blocks are just labelled as suck in cfg.invokes
    Invoke blocks are juste 1-size block with regular edges to the following block*)
let nodes_labels_to_replace (l:label) (n:block node) :(label*block node) list * label list= 
  let new_id id = 
    let Cfg.N_id(i)=l.node_id in
    Cfg.N_id((Printf.sprintf "%s_%i" i id)) in
  let invokes = ref [] in
  let rec foo (b:block list) id = 
    match b with 
    |[]->[]
    |[x]->
      let new_l = {method_id = l.method_id;node_id=new_id id} in
      let _ = try List.tl x with Failure(_) -> invokes:=new_l::!invokes; [] in
      let new_n={value = x;next=n.next} in  [(new_l,new_n)]
    |x::y::q->
      let new_l = {method_id = l.method_id;node_id=new_id id} in 
      let next_l = {method_id = l.method_id;node_id = new_id (id+1)} in 
      let _ = try List.tl x with Failure(_) -> invokes:=new_l::!invokes; [] in
      let new_n = {value = x;next=[(next_l,Regular)]} in (new_l,new_n)::(foo (y::q) (id+1))
  in let blocks = split_block n.value in 
  if List.length blocks = 1 then  ([(l,n)],!invokes) else
  let q = foo (List.tl blocks) 1 in
  let x = (l,{value = List.hd blocks;next = [(fst(List.hd q)),Regular]}) in 
  (x::q,!invokes)


let replace_nodes l cfg = 
  let edg = cfg.edges in 
  let n = Hashtbl.find edg l in 
  let (new_l_n,invokes) = nodes_labels_to_replace l n in 
  Hashtbl.remove edg l;
  List.iter (
    fun (l',n') -> Hashtbl.add edg l' n'
  ) new_l_n;
  {edges = edg; invokes = invokes@cfg.invokes}

let consider_invokes cfg = 
  let l = Hashtbl.fold (fun label _ l' -> label::l') cfg.edges [] in 
  List.fold_left (
    fun cfg' label -> replace_nodes label cfg'
  ) cfg l

